# CS-230
The Gaming Room was my client for this project. They requested a web-based, multi-platform version of their existing Android game, Draw It or Lose It. The goal was to design a system that could run in modern web browsers while preserving the same fast-paced, team-based gameplay experience from the original mobile app. This included managing multiple concurrent games and supporting low-latency communication for timed rounds and progressive image reveals. To meet these requirements, I designed an architecture centered around scalability, real-time synchronization, and efficient resource management.

One thing I did particularly well in this project was developing clear, structured documentation that tied each technical decision back to the clientâ€™s needs. I focused on creating traceability between requirements, constraints, and recommendations- something that would be crucial in an actual software design review. I also found that the process of writing out the design document helped me think more critically about implementation details before coding. Breaking down sections like operating system architecture, storage management, and distributed systems forced me to plan ahead and consider how different environments would interact.

If I were to revise one part of my work, I would expand the System Architecture View section with a more detailed diagram showing the logical flow between services and clients. Visualizing communication paths would help clarify how real-time updates and API calls connect across the architecture. In terms of understanding user needs, I focused heavily on the gameplay flow and responsiveness- two areas that directly impact player experience. Considering user needs is critical in design because it ensures that technical choices serve the end goal: delivering a reliable, intuitive, and enjoyable product.

When approaching software design, I tried to blend structured techniques like UML modeling and architectural layering with practical considerations such as scalability and maintainability. In the future, I would continue using these strategies but also include more iterative user feedback loops during early design stages. Combining technical planning with real user insight ensures the software not only functions well but also meets expectations in usability and performance.
